<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>CRDT Editor - MVP</title>
    <style>
      body { font-family: sans-serif; padding: 12px; }
      textarea { width: 100%; height: 300px; font-size: 16px; }
      #users { margin-top: 10px; padding: 6px; background: #f5f5f5; border: 1px solid #ddd; }
    </style>
  </head>
  <body>
    <h3>CRDT Editor (MVP)</h3>
    <p>Open this page in two windows (different ?user= values) to test realtime.</p>
    <textarea id="editor" placeholder="Type here..."></textarea>

    <div id="users">
      <b>Currently Editing:</b>
      <ul id="userList"></ul>
    </div>

    <script>
      // config from URL
      const params = new URLSearchParams(window.location.search);
      const docId = params.get('doc') ?? 'doc1';
      const clientId = params.get('user') ?? ('u' + Math.floor(Math.random()*9999));
      const username = params.get('name') ?? clientId; // allow ?name=Alice

      const wsUrl = `ws://${location.hostname}:8000/ws/${docId}?client_id=${encodeURIComponent(clientId)}&username=${encodeURIComponent(username)}`;
      const ws = new WebSocket(wsUrl);

      const editor = document.getElementById('editor');
      const userListEl = document.getElementById('userList');

      // local CRDT mirror (array of {id,char,visible})
      let localChars = [];
      let oldText = "";

      // track remote cursors
      const remoteCursors = {}; // userId -> {username, position}

      // temp id counter for optimistic inserts
      let tmpCounter = 1;

      function getVisibleText() {
        return localChars.filter(c => c.visible).map(c => c.char).join('');
      }

      function renderToEditor() {
        const text = getVisibleText();
        editor.value = text;
        oldText = text;
      }

      function renderUsers() {
        userListEl.innerHTML = "";
        for (const [uid, info] of Object.entries(remoteCursors)) {
          const li = document.createElement("li");
          li.textContent = `${info.username} (cursor at ${info.position})`;
          userListEl.appendChild(li);
        }
      }

      function findVisibleIndexByPosition(visiblePos) {
        let count = 0;
        for (let i = 0; i < localChars.length; i++) {
          if (!localChars[i].visible) continue;
          if (count === visiblePos) return i;
          count++;
        }
        return -1;
      }

      function getIdAtVisiblePosition(visiblePos) {
        if (visiblePos < 0) return null;
        const idx = findVisibleIndexByPosition(visiblePos);
        return idx === -1 ? null : localChars[idx].id;
      }

      // Apply remote insert op
      function applyRemoteInsert(op) {
        if (op.client_op_id) {
          const tmpIdx = localChars.findIndex(c => c.id === op.client_op_id);
          if (tmpIdx !== -1) {
            localChars[tmpIdx].id = op.id;
            return;
          }
        }
        const newEntry = { id: op.id, char: op.char, visible: true };
        if (!op.after) {
          localChars.splice(0, 0, newEntry);
        } else {
          const idx = localChars.findIndex(c => c.id === op.after);
          if (idx === -1) {
            localChars.push(newEntry);
          } else {
            localChars.splice(idx + 1, 0, newEntry);
          }
        }
      }

      function applyRemoteDelete(op) {
        const idx = localChars.findIndex(c => c.id === op.id);
        if (idx !== -1) {
          localChars[idx].visible = false;
        }
      }

      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'snapshot') {
          localChars = msg.chars.map(c => ({ id: c.id, char: c.char, visible: c.visible }));
          renderToEditor();
        } else if (msg.type === 'insert') {
          applyRemoteInsert(msg);
          renderToEditor();
        } else if (msg.type === 'delete') {
          applyRemoteDelete(msg);
          renderToEditor();
        } else if (msg.type === 'cursor') {
          // update remote cursor position
          remoteCursors[msg.user_id] = { username: msg.username, position: msg.position };
          renderUsers();
        } else if (msg.type === 'user_list') {
          // full refresh of user list
          remoteCursors = {};
          msg.users.forEach(u => {
            remoteCursors[u.id] = { username: u.username, position: u.cursor };
          });
          renderUsers();
        } else if (msg.type === 'error') {
          console.error("server error:", msg.msg);
        }
      };

      // diff & sending edits
      function computeDiff(a, b) {
        let i = 0;
        while (i < a.length && i < b.length && a[i] === b[i]) i++;
        if (a === b) return [];
        if (a.length < b.length) {
          const inserted = b.slice(i, b.length - (a.length - i));
          return [{ type: 'insert', pos: i, text: inserted }];
        } else {
          const deletedCount = a.length - b.length;
          return [{ type: 'delete', pos: i, count: deletedCount }];
        }
      }

      editor.addEventListener('input', () => {
        const newText = editor.value;
        const diffs = computeDiff(oldText, newText);
        if (!diffs || diffs.length === 0) { oldText = newText; return; }

        for (const d of diffs) {
          if (d.type === 'insert') {
            for (let k = 0; k < d.text.length; k++) {
              const ch = d.text[k];
              const pos = d.pos + k;
              const afterId = pos === 0 ? null : getIdAtVisiblePosition(pos - 1);
              const client_op_id = `tmp-${clientId}-${tmpCounter++}`;
              if (!afterId) {
                localChars.splice(0, 0, { id: client_op_id, char: ch, visible: true });
              } else {
                const idx = localChars.findIndex(c => c.id === afterId);
                if (idx === -1) {
                  localChars.push({ id: client_op_id, char: ch, visible: true });
                } else {
                  localChars.splice(idx + 1, 0, { id: client_op_id, char: ch, visible: true });
                }
              }
              ws.send(JSON.stringify({
                type: 'insert',
                char: ch,
                after: afterId,
                client_op_id: client_op_id
              }));
            }
          } else if (d.type === 'delete') {
            for (let k = 0; k < d.count; k++) {
              const visiblePos = d.pos;
              const idx = findVisibleIndexByPosition(visiblePos);
              if (idx === -1) continue;
              const idToDelete = localChars[idx].id;
              localChars[idx].visible = false;
              ws.send(JSON.stringify({ type: 'delete', id: idToDelete }));
            }
          }
        }
        oldText = newText;
      });

      // send cursor updates
      editor.addEventListener('keyup', () => {
        ws.send(JSON.stringify({
          type: "cursor",
          position: editor.selectionStart
        }));
      });
    </script>
  </body>
</html>
